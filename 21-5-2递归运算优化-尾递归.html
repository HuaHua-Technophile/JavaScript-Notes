<!DOCTYPE html>
<html lang="zh-CN" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="https://i.328888.xyz/2023/04/14/ixDL13.jpeg"
      type="image/png" />
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
    <link
      href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.0-alpha3/css/bootstrap.css"
      rel="stylesheet" />
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.0-alpha3/js/bootstrap.bundle.js"></script>
    <title>21-5-2递归运算优化-尾递归</title>
  </head>
  <body>
    <p>
      尾递归是递归的一种优化算法,它从最后开始计算,每递归一次就算出相应的结果.即:函数调用出现在调用函数的尾部
      <br />因为是尾部所以就不用去保存任何全局变量,返回时带函数可以直接越过调用者,返回到调用者的调用者
    </p>
    <p>下面是使用递归写阶乘的一种方法:</p>
    <script>
      function f(n) {
        return n == 1 ? 1 : n * f(n - 1);
      }
      console.log(f(4)); //24
      // n=4时,普通递归过程如下:
      /* f(4) = {4 * f(3)} */
      /* f(4) = {4 * 3 * f(2)} */
      /* f(4) = {4 * 3 * 2 * f(1)} */
      /* f(4) = {4 * 3 * 2 * 1} */
      /* f(4) = {4 * 3 * 2} */
      /* f(4) = {4 * 6} */
      /* f(4) = 24 */
      function f2(n, a) {
        return n == 1 ? a : f2(n - 1, a * n);
      }
      console.log(f2(4, 1)); //24
      // n=4时,尾递归过程如下:
      /* f2(4 , 1) */
      /* f2(3 , 4) */
      /* f2(2 , 12) */
      /* f2(1 , 24) */
      /*  = 24 */
    </script>
    <p>
      普通递归比尾递归更加消耗资源,每次重复的过程调用都是的调用链条不断加长,系统不得不使用栈进行数据保存和恢复7
      <br />而尾递归的变量完全由n和a保存
    </p>
  </body>
</html>
